<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #000000, #1a1a1a, #2c2c2c);
            font-family: 'Arial', sans-serif;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            animation: bgPulse 10s infinite alternate;
        }
        @keyframes bgPulse {
            0% { background: linear-gradient(135deg, #000000, #1a1a1a, #2c2c2c); }
            100% { background: linear-gradient(135deg, #1a1a1a, #2c2c2c, #000000); }
        }
        h1 {
            font-size: 48px;
            text-shadow: 0 0 20px #ff4500, 0 0 40px #ff6347, 0 0 60px #ff1493;
            margin-bottom: 20px;
            animation: titleGlow 3s infinite alternate;
        }
        @keyframes titleGlow {
            0% { text-shadow: 0 0 20px #ff4500, 0 0 40px #ff6347; }
            100% { text-shadow: 0 0 30px #ff4500, 0 0 50px #ff6347, 0 0 70px #ff1493; }
        }
        canvas {
            border: 5px solid #ff4500;
            background: linear-gradient(45deg, #000, #111);
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5), inset 0 0 10px rgba(255, 69, 0, 0.2);
            animation: canvasGlow 2s infinite alternate;
        }
        @keyframes canvasGlow {
            0% { box-shadow: 0 0 20px rgba(255, 69, 0, 0.5), inset 0 0 10px rgba(255, 69, 0, 0.2); }
            100% { box-shadow: 0 0 30px rgba(255, 69, 0, 1), inset 0 0 15px rgba(255, 69, 0, 0.5); }
        }
        .score {
            font-size: 24px;
            margin: 20px 0;
            text-shadow: 0 0 10px #ff4500;
        }
        .controls {
            font-size: 18px;
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Tetris</h1>
    <div class="score">Score: <span id="score">0</span> | High Score: <span id="highScore">0</span> | Level: <span id="level">1</span></div>
    <div style="display: flex; gap: 20px;">
        <div>
            <canvas id="gameCanvas" width="300" height="600"></canvas>
        </div>
        <div>
            <h3>Next</h3>
            <canvas id="nextCanvas" width="120" height="120"></canvas>
            <h3>Hold</h3>
            <canvas id="holdCanvas" width="120" height="120"></canvas>
        </div>
    </div>
    <div style="margin-top: 20px;">
        <button id="pauseBtn" style="padding: 10px 20px; font-size: 18px; margin-right: 10px;">Pause</button>
        <button onclick="window.parent.postMessage('goHome', '*');" style="padding: 10px 20px; font-size: 18px; background: #ffd700; color: #000; border: none; border-radius: 5px; cursor: pointer;">홈으로</button>
    </div>
    <div class="controls">
        Arrow keys: Move/rotate<br>
        Space: Drop fast<br>
        Fill lines to score!
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const holdCanvas = document.getElementById('holdCanvas');
        const holdCtx = holdCanvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const levelEl = document.getElementById('level');

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            oscillator.type = type;
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function playBGM() {
            if (!soundEnabled) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
            oscillator.type = 'triangle';
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            oscillator.frequency.setValueAtTime(330, audioCtx.currentTime + 1);
            oscillator.frequency.setValueAtTime(440, audioCtx.currentTime + 2);
            oscillator.start();
            setTimeout(() => oscillator.stop(), 8000);
        }

        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 30;

        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        let score = 0;
        let highScore = parseInt(localStorage.getItem('tetris_highScore')) || 0;
        let level = 1;
        let linesCleared = 0;
        let currentPiece = null;
        let nextPiece = null;
        let holdPiece = null;
        let canHold = true;
        let gameRunning = true;
        let paused = false;
        let soundEnabled = true;

        highScoreEl.textContent = highScore;
        levelEl.textContent = level;

        const pieces = [
            { shape: [[1,1,1,1]], color: '#00f5ff' }, // I - cyan
            { shape: [[1,1],[1,1]], color: '#ffff00' }, // O - yellow
            { shape: [[1,0,0],[1,1,1]], color: '#0000ff' }, // J - blue
            { shape: [[0,0,1],[1,1,1]], color: '#ffa500' }, // L - orange
            { shape: [[0,1,1],[1,1,0]], color: '#00ff00' }, // S - green
            { shape: [[1,1,0],[0,1,1]], color: '#ff0000' }, // Z - red
            { shape: [[0,1,0],[1,1,1]], color: '#800080' }  // T - purple
        ];

        function drawBoard() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        ctx.fillStyle = board[r][c];
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }
        }

        function spawnPiece() {
            if (!nextPiece) {
                nextPiece = createPiece();
            }
            currentPiece = nextPiece;
            nextPiece = createPiece();
            drawNext();
        }

        function createPiece() {
            const type = Math.floor(Math.random() * pieces.length);
            return {
                shape: pieces[type].shape,
                color: pieces[type].color,
                x: Math.floor(COLS / 2) - 1,
                y: 0
            };
        }

        function drawNext() {
            nextCtx.fillStyle = '#000';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                drawPiece(nextPiece, nextCtx, 1, 1, 20);
            }
        }

        function drawHold() {
            holdCtx.fillStyle = '#000';
            holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
            if (holdPiece) {
                drawPiece(holdPiece, holdCtx, 1, 1, 20);
            }
        }

        function drawPiece(piece, ctx, offsetX = 0, offsetY = 0, blockSize = BLOCK_SIZE) {
            if (!piece) return;
            ctx.fillStyle = piece.color;
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c]) {
                        ctx.fillRect((piece.x + c + offsetX) * blockSize, (piece.y + r + offsetY) * blockSize, blockSize - 1, blockSize - 1);
                    }
                }
            }
        }

        function movePiece(dx, dy) {
            currentPiece.x += dx;
            currentPiece.y += dy;
            if (collision()) {
                currentPiece.x -= dx;
                currentPiece.y -= dy;
                if (dy > 0) {
                    placePiece();
                    clearLines();
                    spawnPiece();
                    canHold = true;
                }
                return false;
            }
            return true;
        }

        function collision() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        const newX = currentPiece.x + c;
                        const newY = currentPiece.y + r;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function placePiece() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
                    }
                }
            }
        }

        function clearLines() {
            let cleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell)) {
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(null));
                    cleared++;
                    r++; // Check same row again
                }
            }
            if (cleared > 0) {
                score += cleared * 100 * level;
                linesCleared += cleared;
                level = Math.floor(linesCleared / 10) + 1;
                levelEl.textContent = level;
                scoreEl.textContent = score;
                if (score > highScore) {
                    highScore = score;
                    highScoreEl.textContent = highScore;
                    localStorage.setItem('tetris_highScore', highScore);
                }
                playSound(800, 0.5, 'triangle', 0.2);
                if (cleared >= 4) playBGM(); // Tetris!
            }
        }

        function rotatePiece() {
            const rotated = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i]).reverse());
            const prevShape = currentPiece.shape;
            currentPiece.shape = rotated;
            if (collision()) {
                currentPiece.shape = prevShape;
            }
        }

        function gameLoop() {
            if (!gameRunning || paused) return;
            drawBoard();
            drawPiece(currentPiece, ctx);
        }

        document.addEventListener('keydown', (e) => {
            if (!gameRunning || paused) return;
            switch (e.key) {
                case 'ArrowLeft':
                    if (movePiece(-1, 0)) playSound(300, 0.1, 'square');
                    break;
                case 'ArrowRight':
                    if (movePiece(1, 0)) playSound(300, 0.1, 'square');
                    break;
                case 'ArrowDown':
                    if (movePiece(0, 1)) playSound(400, 0.1, 'square');
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    playSound(500, 0.2, 'sawtooth');
                    break;
                case ' ':
                    while (movePiece(0, 1)) {}
                    playSound(600, 0.3, 'triangle');
                    break;
                case 'c':
                case 'C':
                    if (canHold) {
                        if (holdPiece) {
                            [currentPiece, holdPiece] = [holdPiece, currentPiece];
                            currentPiece.x = Math.floor(COLS / 2) - 1;
                            currentPiece.y = 0;
                        } else {
                            holdPiece = currentPiece;
                            spawnPiece();
                        }
                        drawHold();
                        canHold = false;
                        playSound(700, 0.2, 'sine');
                    }
                    break;
            }
        });

        spawnPiece();
        let dropInterval = setInterval(() => {
            if (gameRunning && !paused) {
                movePiece(0, 1);
            }
        }, 500 / level);
        setInterval(gameLoop, 100);

        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        // Listen for settings from parent
        window.addEventListener('message', (e) => {
            if (e.data.type === 'settings') {
                soundEnabled = e.data.settings.soundEnabled;
            }
        });
    </script>
</body>
</html></content>
<parameter name="filePath">c:\grokcoding\grok_project_21\tetris.html